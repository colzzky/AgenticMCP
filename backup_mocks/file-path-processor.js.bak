import { jest } from '@jest/globals';

// In-memory test state for the mock
const fileProcessorState = {
  // Track calls and results for test verification
  processArgsCalls: [],
  contexts: {},
  
  // Reset state between tests
  reset() {
    this.processArgsCalls = [];
    this.contexts = {};
  },
  
  // Record a file content for a specific path
  setFileContent(path, content) {
    this.contexts[path] = content;
  }
};

// In-memory state for test data
const mockFileSystem = {
  files: new Map(),
  directories: new Set(),
  reset() {
    this.files.clear();
    this.directories.clear();
  },
  addFile(path, content) {
    this.files.set(path, content);
    // Also add the directory
    const dirPath = path.slice(0, path.lastIndexOf('/'));
    if (dirPath) this.directories.add(dirPath);
  },
  addDirectory(path) {
    this.directories.add(path);
  },
  exists(path) {
    return this.files.has(path) || this.directories.has(path);
  },
  isFile(path) {
    return this.files.has(path);
  },
  isDirectory(path) {
    return this.directories.has(path);
  },
  getFileContent(path) {
    return this.files.get(path);
  }
};

/**
 * Shared implementation of processArgs that can be used by both mock classes
 */
async function processArgsImplementation(args, logger) {
  // Default implementation for tests
  const filePaths = [];
  const remainingArgs = [];

  // Identify file paths (any arg that exists in our mock file system)
  for (const arg of args) {
    if (mockFileSystem.exists(arg)) {
      filePaths.push(arg);
    } else {
      remainingArgs.push(arg);
    }
  }

  // Build context string from mock file contents
  let context = '';
  for (const filePath of filePaths) {
    const content = mockFileSystem.getFileContent(filePath);
    if (content) {
      if (context) context += '\n\n';
      const basename = filePath.split('/').pop();
      context += `--- ${basename} ---\n${content}`;
    }
  }

  if (logger && filePaths.length > 0) {
    logger.debug(`Added ${filePaths.length} files to context`);
  }

  return { context, remainingArgs };
}

/**
 * Mock for the original FilePathProcessor class
 */
class MockFilePathProcessor {
  constructor(logger) {
    this.logger = logger || { debug: jest.fn(), error: jest.fn() };
    this.processArgsSpy = jest.fn();
  }

  /**
   * Process arguments, extracting file paths and loading them as context
   * @param {Array<string>} args - Command arguments
   * @returns {Promise<{context: string, remainingArgs: string[]}>}
   */
  async processArgs(args) {
    // Call the spy to track calls for testing
    this.processArgsSpy(args);
    return processArgsImplementation(args, this.logger);
  }
}

/**
 * Mock for the DI-enabled FilePathProcessor class
 */
class MockDIFilePathProcessor {
  constructor(logger, fileSystem) {
    this.logger = logger || { debug: jest.fn(), error: jest.fn() };
    this.fileSystem = fileSystem || {
      access: jest.fn(),
      readFile: jest.fn(),
      stat: jest.fn()
    };
    this.processArgsSpy = jest.fn();
  }

  /**
   * Process arguments, extracting file paths and loading them as context
   * @param {Array<string>} args - Command arguments
   * @returns {Promise<{context: string, remainingArgs: string[]}>}
   */
  async processArgs(args) {
    // Call the spy to track calls for testing
    this.processArgsSpy(args);
    return processArgsImplementation(args, this.logger);
  }
}

// Export the classes and mockFileSystem for test manipulation
module.exports = {
  // Export the class as default and named export
  default: MockFilePathProcessor,
  FilePathProcessor: MockFilePathProcessor,
  DIFilePathProcessor: MockDIFilePathProcessor,
  mockFileSystem
};

// Create a mock that simulates the actual implementation
export const FilePathProcessor = jest.fn().mockImplementation((logger) => {
  return {
    processArgs: jest.fn(async (arguments_) => {
      // Track the call arguments for verification
      fileProcessorState.processArgsCalls.push(arguments_);
      
      // Simulate the real behavior: identify file paths in arguments
      const argumentArray = Array.isArray(arguments_) ? arguments_ : [];
      const filePaths = argumentArray.filter(argument => typeof argument === 'string' && 
        (argument.includes('.txt') || argument.includes('.md')));
      const remainingArguments = argumentArray.filter(argument => !filePaths.includes(argument));
      
      // Generate context based on identified file paths
      let context = '';
      
      if (filePaths.length > 0) {
        // Special case handling for test scenarios
        const specialPaths = {
          '/test/error.txt': '',  // Error case returns empty content
          '/test/dir': 'File content', // Directory content 
        };
        
        // Use provided content in __testState if available, otherwise fallback to defaults
        const pathContents = filePaths.map(path => {
          // Check if we have predefined content in state
          if (path in fileProcessorState.contexts) {
            return `${path}:\n${fileProcessorState.contexts[path]}`;
          }
          // Check for special test paths
          else if (path in specialPaths) {
            return `${path}:\n${specialPaths[path]}`;
          }
          // Default case
          return `${path}:\nDefault file content`;
        });
        
        context = `--- File Content ---\n${pathContents.join('\n')}\n`;
      }
      
      // LLMCommand test case - ensure we return content for file.txt and example.md
      if (argumentArray.includes('file.txt') || argumentArray.includes('example.md')) {
        return {
          context: 'File Content for test files',
          remainingArguments: argumentArray.filter(argument => 
            !argument.includes('.txt') && !argument.includes('.md'))
        };
      }

      // Special case for certain test patterns
      if (arguments_ && arguments_.includes && arguments_.includes('/test/nonexistent.txt')) {
        return { 
          context: '',
          remainingArguments: ['command', '/test/nonexistent.txt', 'prompt text'] 
        };
      }
      
      if (arguments_ && arguments_.includes && arguments_.includes('/test/dir')) {
        return {
          context: 'File content',
          remainingArguments: ['command', 'prompt text']
        };
      }
      
      if (arguments_ && arguments_.includes && arguments_.includes('/test/error.txt')) {
        return {
          context: '', // Error case should return empty context
          remainingArguments: ['command', 'prompt text']
        };
      }
      
      // Default return preserves behavior
      return { context, remainingArguments };
    })
  };
});
